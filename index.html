<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game - è´ªåƒè›‡æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #535353;
            margin-bottom: 10px;
            text-align: center;
            font-size: 36px;
        }

        .subtitle {
            text-align: center;
            color: #757575;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 600px;
        }

        .info-box {
            background: #f5f5f5;
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
        }

        .info-label {
            font-size: 12px;
            color: #757575;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 28px;
            font-weight: bold;
            color: #535353;
        }

        .canvas-container {
            position: relative;
            background: #faf8f5;
            border-radius: 10px;
            padding: 10px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #gameCanvas {
            display: block;
            border-radius: 5px;
            background: #f0ebe0;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .control-btn {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .start-btn {
            background: #535353;
            color: white;
        }

        .start-btn:hover {
            background: #666;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .pause-btn {
            background: #e8d5b7;
            color: #535353;
        }

        .pause-btn:hover {
            background: #d9c6a8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .instructions {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .instructions h3 {
            color: #535353;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .instructions p {
            color: #666;
            line-height: 1.8;
            margin-bottom: 5px;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 5px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .overlay-text {
            font-size: 48px;
            font-weight: bold;
            color: #535353;
            margin-bottom: 20px;
        }

        .overlay-subtitle {
            font-size: 18px;
            color: #757575;
        }

        @media (max-width: 700px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 28px;
            }

            #gameCanvas {
                width: 100%;
                height: auto;
            }

            .info-value {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ Snake Game</h1>
        <p class="subtitle">è´ªåƒè›‡æ¸¸æˆ</p>

        <div class="game-wrapper">
            <div class="game-info">
                <div class="info-box">
                    <div class="info-label">Score / åˆ†æ•°</div>
                    <div class="info-value" id="score">0</div>
                </div>
                <div class="info-box">
                    <div class="info-label">High Score / æœ€é«˜åˆ†</div>
                    <div class="info-value" id="highScore">0</div>
                </div>
                <div class="info-box">
                    <div class="info-label">Speed / é€Ÿåº¦</div>
                    <div class="info-value" id="speed">1</div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
                <div class="overlay" id="overlay">
                    <div class="overlay-text" id="overlayText">Game Over</div>
                    <div class="overlay-subtitle" id="overlaySubtitle">Press Space or click Start to play again</div>
                </div>
            </div>

            <div class="controls">
                <button class="control-btn start-btn" id="startBtn">Start / å¼€å§‹</button>
                <button class="control-btn pause-btn" id="pauseBtn">Pause / æš‚åœ</button>
            </div>

            <div class="instructions">
                <h3>ğŸ“– How to Play / æ¸¸æˆè¯´æ˜</h3>
                <p><strong>English:</strong> Use arrow keys or WASD to control the snake. Eat the food to grow longer and increase your score. The game speeds up as you score more points. Avoid hitting the walls or yourself!</p>
                <p><strong>ä¸­æ–‡:</strong> ä½¿ç”¨æ–¹å‘é”®æˆ–WASDæ§åˆ¶è›‡çš„ç§»åŠ¨ã€‚åƒæ‰é£Ÿç‰©æ¥å¢é•¿èº«ä½“å¹¶è·å¾—åˆ†æ•°ã€‚åˆ†æ•°è¶Šé«˜ï¼Œé€Ÿåº¦è¶Šå¿«ã€‚é¿å…æ’åˆ°å¢™å£æˆ–è‡ªå·±çš„èº«ä½“ï¼</p>
                <p><strong>Controls:</strong> â†‘â†“â†â†’ or WASD | <strong>æ§åˆ¶:</strong> æ–¹å‘é”®æˆ–WASD</p>
            </div>
        </div>

        <div style="text-align: center; margin-top: 30px;">
            <a href="about.html" style="color: #535353; text-decoration: none; font-weight: bold;">ğŸ“– About / å…³äº</a>
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            GRID_SIZE: 20,
            CANVAS_SIZE: 600,
            CELL_SIZE: 30,
            INITIAL_SPEED: 750,
            SPEED_INCREMENT: 25,
            MIN_SPEED: 250,
            POINTS_PER_FOOD: 10,
            SPEED_INCREASE_INTERVAL: 50
        };

        // Audio Context for sound effects
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
            }

            init() {
                if (!this.initialized) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                }
            }

            playTone(frequency, duration, type = 'square') {
                if (!this.initialized) this.init();

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = type;

                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            playEat() {
                this.playTone(523.25, 0.1, 'sine');
                setTimeout(() => this.playTone(659.25, 0.1, 'sine'), 100);
            }

            playGameOver() {
                this.playTone(293.66, 0.2, 'sawtooth');
                setTimeout(() => this.playTone(246.94, 0.2, 'sawtooth'), 200);
                setTimeout(() => this.playTone(196.00, 0.3, 'sawtooth'), 400);
            }

            playMove() {
                this.playTone(200, 0.05, 'square');
            }
        }

        // Game State
        const state = {
            snake: [],
            direction: { x: 1, y: 0 },
            nextDirection: { x: 1, y: 0 },
            food: { x: 0, y: 0 },
            score: 0,
            highScore: parseInt(localStorage.getItem('snakeHighScore')) || 0,
            speed: 1,
            gameLoop: null,
            isPlaying: false,
            isPaused: false,
            isGameOver: false
        };

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const speedEl = document.getElementById('speed');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const overlay = document.getElementById('overlay');
        const overlayText = document.getElementById('overlayText');
        const overlaySubtitle = document.getElementById('overlaySubtitle');

        const audio = new AudioManager();

        // Initialize game
        function init() {
            const startX = Math.floor(CONFIG.GRID_SIZE / 4);
            const startY = Math.floor(CONFIG.GRID_SIZE / 2);

            state.snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];

            state.direction = { x: 1, y: 0 };
            state.nextDirection = { x: 1, y: 0 };
            state.score = 0;
            state.speed = 1;
            state.isGameOver = false;
            state.isPaused = false;

            generateFood();
            updateUI();
            draw();
        }

        // Generate food at random position
        function generateFood() {
            let position;
            do {
                position = {
                    x: Math.floor(Math.random() * CONFIG.GRID_SIZE),
                    y: Math.floor(Math.random() * CONFIG.GRID_SIZE)
                };
            } while (isOnSnake(position));

            state.food = position;
        }

        // Check if position is on snake
        function isOnSnake(pos) {
            return state.snake.some(segment => segment.x === pos.x && segment.y === pos.y);
        }

        // Update game state
        function update() {
            if (state.isPaused || state.isGameOver) return;

            state.direction = { ...state.nextDirection };

            const head = {
                x: state.snake[0].x + state.direction.x,
                y: state.snake[0].y + state.direction.y
            };

            // Check wall collision
            if (head.x < 0 || head.x >= CONFIG.GRID_SIZE ||
                head.y < 0 || head.y >= CONFIG.GRID_SIZE) {
                gameOver();
                return;
            }

            // Check self collision
            if (isOnSnake(head)) {
                gameOver();
                return;
            }

            state.snake.unshift(head);

            // Check food collision
            if (head.x === state.food.x && head.y === state.food.y) {
                state.score += CONFIG.POINTS_PER_FOOD;
                audio.playEat();

                // Increase speed every SPEED_INCREASE_INTERVAL points
                if (state.score % CONFIG.SPEED_INCREASE_INTERVAL === 0) {
                    state.speed++;
                    updateGameSpeed();
                }

                if (state.score > state.highScore) {
                    state.highScore = state.score;
                    localStorage.setItem('snakeHighScore', state.highScore);
                }

                generateFood();
            } else {
                state.snake.pop();
            }

            updateUI();
        }

        // Draw game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#f0ebe0';
            ctx.fillRect(0, 0, CONFIG.CANVAS_SIZE, CONFIG.CANVAS_SIZE);

            // Draw grid (subtle)
            ctx.strokeStyle = '#e8e0d0';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= CONFIG.GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CONFIG.CELL_SIZE, 0);
                ctx.lineTo(i * CONFIG.CELL_SIZE, CONFIG.CANVAS_SIZE);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * CONFIG.CELL_SIZE);
                ctx.lineTo(CONFIG.CANVAS_SIZE, i * CONFIG.CELL_SIZE);
                ctx.stroke();
            }

            // Draw food with animation
            const foodCenterX = state.food.x * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
            const foodCenterY = state.food.y * CONFIG.CELL_SIZE + CONFIG.CELL_SIZE / 2;
            const foodRadius = CONFIG.CELL_SIZE / 2 - 4;

            // Pulsing effect
            const pulse = Math.sin(Date.now() / 200) * 2;

            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(foodCenterX, foodCenterY, foodRadius + pulse, 0, Math.PI * 2);
            ctx.fill();

            // Food shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(foodCenterX - 3, foodCenterY - 3, 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw snake with gradient
            state.snake.forEach((segment, index) => {
                const x = segment.x * CONFIG.CELL_SIZE;
                const y = segment.y * CONFIG.CELL_SIZE;
                const size = CONFIG.CELL_SIZE - 2;

                // Gradient from head to tail
                const hue = 120 + (index * 2);
                const saturation = 60 - (index * 0.5);
                const lightness = 50 - (index * 0.3);

                if (index === 0) {
                    // Snake head
                    ctx.fillStyle = '#27ae60';
                    ctx.shadowColor = '#2ecc71';
                    ctx.shadowBlur = 10;
                } else {
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                ctx.roundRect(x + 1, y + 1, size, size, 5);
                ctx.fill();

                // Eyes on head
                if (index === 0) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 0;

                    let eyeOffset1, eyeOffset2;
                    if (state.direction.x === 1) {
                        eyeOffset1 = { x: 18, y: 8 };
                        eyeOffset2 = { x: 18, y: 18 };
                    } else if (state.direction.x === -1) {
                        eyeOffset1 = { x: 8, y: 8 };
                        eyeOffset2 = { x: 8, y: 18 };
                    } else if (state.direction.y === 1) {
                        eyeOffset1 = { x: 8, y: 18 };
                        eyeOffset2 = { x: 18, y: 18 };
                    } else {
                        eyeOffset1 = { x: 8, y: 8 };
                        eyeOffset2 = { x: 18, y: 8 };
                    }

                    ctx.beginPath();
                    ctx.arc(x + eyeOffset1.x, y + eyeOffset1.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + eyeOffset2.x, y + eyeOffset2.y, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Pupils
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(x + eyeOffset1.x, y + eyeOffset1.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + eyeOffset2.x, y + eyeOffset2.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.shadowBlur = 0;
        }

        // Animation loop
        function gameLoopFn() {
            update();
            draw();
            requestAnimationFrame(gameLoopFn);
        }

        // Update UI elements
        function updateUI() {
            scoreEl.textContent = state.score;
            highScoreEl.textContent = state.highScore;
            speedEl.textContent = state.speed;
        }

        // Calculate current game speed
        function getCurrentSpeed() {
            return Math.max(
                CONFIG.MIN_SPEED,
                CONFIG.INITIAL_SPEED - (state.speed - 1) * CONFIG.SPEED_INCREMENT
            );
        }

        // Update game loop speed
        function updateGameSpeed() {
            if (state.gameLoop) {
                clearInterval(state.gameLoop);
                state.gameLoop = setInterval(update, getCurrentSpeed());
            }
        }

        // Start game
        function startGame() {
            audio.init();

            if (state.gameLoop) {
                clearInterval(state.gameLoop);
            }

            init();
            state.isPlaying = true;
            state.isPaused = false;
            overlay.classList.remove('active');
            startBtn.textContent = 'Restart / é‡æ–°å¼€å§‹';
            pauseBtn.textContent = 'Pause / æš‚åœ';

            state.gameLoop = setInterval(update, getCurrentSpeed());
            gameLoopFn();
        }

        // Pause/Resume game
        function togglePause() {
            if (!state.isPlaying) return;

            state.isPaused = !state.isPaused;

            if (state.isPaused) {
                overlayText.textContent = 'Paused';
                overlaySubtitle.textContent = 'Press Space or click Pause to continue';
                overlay.classList.add('active');
                pauseBtn.textContent = 'Resume / ç»§ç»­';
            } else {
                overlay.classList.remove('active');
                pauseBtn.textContent = 'Pause / æš‚åœ';
            }
        }

        // Game over
        function gameOver() {
            state.isGameOver = true;
            state.isPlaying = false;

            if (state.gameLoop) {
                clearInterval(state.gameLoop);
                state.gameLoop = null;
            }

            audio.playGameOver();

            overlayText.textContent = 'Game Over!';
            overlaySubtitle.textContent = `Final Score: ${state.score} | Press Space or click Start to play again`;
            overlay.classList.add('active');
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            // Prevent default for game keys
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                e.preventDefault();
            }

            // Start/Restart with Space
            if (e.code === 'Space') {
                if (state.isGameOver || !state.isPlaying) {
                    startGame();
                } else {
                    togglePause();
                }
                return;
            }

            if (!state.isPlaying || state.isPaused) return;

            audio.playMove();

            switch (e.code) {
                case 'ArrowUp':
                case 'KeyW':
                    if (state.direction.y !== 1) {
                        state.nextDirection = { x: 0, y: -1 };
                    }
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    if (state.direction.y !== -1) {
                        state.nextDirection = { x: 0, y: 1 };
                    }
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    if (state.direction.x !== 1) {
                        state.nextDirection = { x: -1, y: 0 };
                    }
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    if (state.direction.x !== -1) {
                        state.nextDirection = { x: 1, y: 0 };
                    }
                    break;
            }
        });

        // Button event listeners
        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', togglePause);

        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            audio.init();
        });

        canvas.addEventListener('touchend', (e) => {
            if (!state.isPlaying || state.isPaused) return;

            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            audio.playMove();

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 30 && state.direction.x !== -1) {
                    state.nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -30 && state.direction.x !== 1) {
                    state.nextDirection = { x: -1, y: 0 };
                }
            } else {
                if (deltaY > 30 && state.direction.y !== -1) {
                    state.nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -30 && state.direction.y !== 1) {
                    state.nextDirection = { x: 0, y: -1 };
                }
            }
        });

        // Initial draw
        init();
    </script>
</body>
</html>
